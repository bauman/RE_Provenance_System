"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const d3 = require("d3");
require("./style.css");
const provenance_core_1 = require("@visualstorytelling/provenance-core");
function firstArgThis(f) {
    return function (...args) {
        return f(this, ...args);
    };
}
class SlideDeckVisualization {
    constructor(slideDeck, elm) {
        this._tableHeight = 1000;
        this._tableWidth = 300;
        this._minimumSlideDuration = 5000;
        this._barHeightTimeMultiplier = 0.01;
        this._barWidth = 270;
        this._barPadding = 5;
        this._resizebarheight = 5;
        this._previousSlideY = 0;
        this._lineX1 = 30;
        this._placeholderWidth = this._tableWidth - 40;
        this._placeholderY = 50;
        this._placeholderHeight = 30;
        this._maxSlides = 20;
        this._toolbarX = 200;
        this._toolbarY = 10;
        this._toolbarPadding = 20;
        this._slideDuration = 1000;
        this._timeIndexedSlides = [];
        this._nextSlideY = 50;
        this._index = (slide) => {
            return this._slideDeck.slides.indexOf(slide);
        };
        this.onDelete = (slide) => {
            this._slideDeck.removeSlide(slide);
        };
        this.onSelect = (slide) => {
            if (d3.event.defaultPrevented)
                return;
            this._slideDeck.selectedSlide = slide;
        };
        this.onAdd = () => {
            let slideDeck = this._slideDeck;
            const node = slideDeck.graph.current;
            const slide = new provenance_core_1.ProvenanceSlide(node.label, 1000, 0, [], node);
            slideDeck.addSlide(slide, slideDeck.selectedSlide
                ? slideDeck.slides.indexOf(slideDeck.selectedSlide) + 1
                : slideDeck.slides.length);
        };
        this.onClone = (slide) => {
            let slideDeck = this._slideDeck;
            const cloneSlide = new provenance_core_1.ProvenanceSlide(slide.name, 1000, 0, [], slide.node);
            slideDeck.addSlide(cloneSlide, slideDeck.selectedSlide
                ? slideDeck.slides.indexOf(slideDeck.selectedSlide) + 1
                : slideDeck.slides.length);
        };
        this.moveDragged = (that, draggedObject) => {
            d3.select(that).attr("transform", (slide) => {
                const originalY = this.previousSlidesHeight(slide);
                const draggedY = d3.event.y;
                const myIndex = this._slideDeck.slides.indexOf(slide);
                if (draggedY < originalY && myIndex > 0) {
                    // check upwards
                    const previousSlide = this._slideDeck.slides[myIndex - 1];
                    let previousSlideCenterY = this.previousSlidesHeight(previousSlide) +
                        this.barTotalHeight(previousSlide) / 2;
                    if (draggedY < previousSlideCenterY) {
                        this._slideDeck.moveSlide(myIndex, myIndex - 1);
                    }
                }
                else if (draggedY > originalY &&
                    myIndex < this._slideDeck.slides.length - 1) {
                    // check downwards
                    const nextSlide = this._slideDeck.slides[myIndex + 1];
                    let nextSlideCenterY = this.previousSlidesHeight(nextSlide) +
                        this.barTotalHeight(nextSlide) / 2;
                    if (draggedY > nextSlideCenterY) {
                        this._slideDeck.moveSlide(myIndex, myIndex + 1);
                    }
                }
                return "translate(30," + d3.event.y + ")";
            });
        };
        this.moveDragended = (that, draggedObject) => {
            d3.select(that)
                .classed("active", false)
                .attr("transform", (slide) => {
                return "translate(30," + this.previousSlidesHeight(slide) + ")";
            });
        };
        this.delayDragged = (that, slide) => {
            slide.delay = Math.max(0, d3.event.y) / this._barHeightTimeMultiplier;
            this.update();
        };
        this.delaySubject = (that, slide) => {
            return { y: this.barDelayHeight(slide) };
        };
        this.durationDragged = (that, slide) => {
            slide.duration =
                Math.max(0, d3.event.y) / this._barHeightTimeMultiplier;
            this.update();
        };
        this.durationSubject = (that, slide) => {
            return { y: this.barDurationHeight(slide) };
        };
        this.onNext = () => {
            this._slideDeck.next();
        };
        this.onPrevious = () => {
            this._slideDeck.previous();
        };
        this.onPlay = () => {
            if (this._player.status === provenance_core_1.STATUS.IDLE) {
                this._player.play();
            }
            else {
                this._player.stop();
            }
            d3.select(d3.event.target).classed("fa-play", d3.select(d3.event.target).classed("fa-play") ? false : true);
            d3.select(d3.event.target).classed("fa-pause", d3.select(d3.event.target).classed("fa-pause") ? false : true);
        };
        this._slideDeck = slideDeck;
        this._root = d3.select(elm);
        this._slideTable = this._root
            .append("svg")
            .attr("class", "slide__table")
            .attr("height", this._tableHeight)
            .attr("width", this._tableWidth);
        this._slideTable
            .append("rect")
            .attr("class", "slides_background_rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("height", this._tableHeight)
            .attr("width", this._tableWidth);
        this._slideTable
            .append("line")
            .attr("x1", this._lineX1)
            .attr("y1", this._nextSlideY)
            .attr("x2", this._lineX1)
            .attr("stroke", "gray")
            .attr("stroke-width", 2);
        this._slideTable
            .append("circle")
            .attr("class", "currentTime")
            .attr("cx", this._lineX1)
            .attr("cy", this._nextSlideY)
            .attr("r", 3)
            .attr("fill", "red");
        this.setPlaceholder("slide_placeholder");
        this.setPlaceholder("player_placeholder");
        this.setAddButton();
        this.setPreviousButton();
        this.setPlayButton();
        this.setNextButton();
        slideDeck.on("slideAdded", () => this.update());
        slideDeck.on("slideRemoved", () => this.update());
        slideDeck.on("slidesMoved", () => this.update());
        slideDeck.on("slideSelected", () => this.update());
        this._player = new provenance_core_1.ProvenanceSlidedeckPlayer(this._slideDeck.slides, nextSlide => {
            this._slideDuration = nextSlide.duration;
            this._nextSlideY += this.barTotalHeight(nextSlide);
            this._slideDeck.selectedSlide = nextSlide;
        });
        this.update();
    }
    onMouseEnter() {
        let toolbar = d3.event.target.parentElement.querySelector(".slide_toolbar");
        toolbar.style.display = "block";
    }
    onMouseLeave() {
        let toolbar = d3.event.target.parentElement.querySelector(".slide_toolbar");
        toolbar.style.display = "none";
    }
    moveDragStarted(draggedObject) {
        d3.select(this)
            .raise()
            .classed("active", true);
    }
    barDelayHeight(slide) {
        let calculatedHeight = this._barHeightTimeMultiplier * slide.delay;
        return Math.max(calculatedHeight, 0);
    }
    barDurationHeight(slide) {
        let calculatedHeight = this._barHeightTimeMultiplier * slide.duration;
        return Math.max(calculatedHeight, this._minimumSlideDuration * this._barHeightTimeMultiplier);
    }
    barTotalHeight(slide) {
        let calculatedHeight = this.barDelayHeight(slide) +
            this.barDurationHeight(slide) +
            2 * this._resizebarheight;
        return calculatedHeight;
    }
    previousSlidesHeight(slide) {
        let myIndex = this._slideDeck.slides.indexOf(slide);
        let calculatedHeight = 50;
        for (let i = 0; i < myIndex; i++) {
            calculatedHeight += this.barTotalHeight(this._slideDeck.slides[i]);
        }
        return calculatedHeight;
    }
    updateTimeIndices(slideDeck) {
        this._timeIndexedSlides = [];
        let timeIndex = 0;
        slideDeck.slides.forEach(slide => {
            this._timeIndexedSlides.push({
                slide: slide,
                startTime: timeIndex
            });
            timeIndex += slide.delay + slide.duration;
        });
    }
    update() {
        this.updateTimeIndices(this._slideDeck);
        const allExistingNodes = this._slideTable
            .selectAll("g.slide")
            .data(this._slideDeck.slides, (d) => {
            return d.id;
        });
        const that = this;
        const newNodes = allExistingNodes
            .enter()
            .append("g")
            .attr("class", "slide")
            .call(d3.drag()
            .clickDistance([2, 2])
            .on("start", this.moveDragStarted)
            .on("drag", firstArgThis(this.moveDragged))
            .on("end", firstArgThis(this.moveDragended)));
        newNodes
            .append("rect")
            .attr("class", "slides_delay_resize")
            .attr("x", this._barPadding)
            .attr("width", this._barWidth - 2 * this._barPadding)
            .attr("height", this._resizebarheight)
            .attr("cursor", "ns-resize")
            .call(d3.drag()
            .subject(firstArgThis(this.delaySubject))
            .on("drag", firstArgThis(this.delayDragged)));
        newNodes
            .append("rect")
            .attr("class", "slides_delay_rect")
            .attr("x", this._barPadding)
            .attr("y", 0)
            .attr("width", this._barWidth - 2 * this._barPadding)
            .on("click", this.onSelect);
        let slideGroup = newNodes
            .append("g")
            .attr("transform", "translate(5,0)")
            .attr("class", "slide_group")
            .on("mouseenter", this.onMouseEnter)
            .on("mouseleave", this.onMouseLeave);
        slideGroup
            .append("rect")
            .attr("class", "slides_rect")
            .attr("width", this._barWidth - 2 * this._barPadding)
            .attr("cursor", "move")
            .on("click", this.onSelect);
        slideGroup
            .append("text")
            .attr("class", "slides_text")
            .attr("x", 2 * this._barPadding)
            .attr("dy", ".35em");
        slideGroup
            .append("text")
            .attr("class", "slides_delaytext")
            .attr("x", 2 * this._barPadding)
            .attr("dy", ".35em");
        let toolbar = slideGroup.append("g").attr("class", "slide_toolbar");
        toolbar
            .append("svg:foreignObject")
            .attr("class", "slides_delete_icon")
            .attr("x", this._toolbarX)
            .attr("cursor", "pointer")
            .attr("width", 20)
            .attr("height", 20)
            .append("xhtml:body")
            .on("click", this.onDelete)
            .html('<i class="fa fa-trash-o"></i>');
        toolbar
            .append("svg:foreignObject")
            .attr("class", "slides_clone_icon")
            .attr("x", this._toolbarX + this._toolbarPadding)
            .attr("cursor", "pointer")
            .attr("width", 20)
            .attr("height", 20)
            .append("xhtml:body")
            .on("click", this.onClone)
            .html('<i class="fa fa-copy"></i>');
        const slidePlaceholder = this._slideTable.select("rect#slide_placeholder");
        const playerPlaceholder = this._slideTable.select("rect#player_placeholder");
        newNodes
            .append("text")
            .attr("class", "slides_durationtext")
            .attr("x", this._barPadding - 30)
            .attr("dy", "-.65em");
        newNodes
            .append("circle")
            .attr("class", "time")
            .attr("cx", 0)
            .attr("r", 3)
            .attr("fill", "black");
        newNodes
            .append("rect")
            .attr("class", "slides_duration_resize")
            .attr("x", this._barPadding)
            .attr("width", this._barWidth - 2 * this._barPadding)
            .attr("height", this._resizebarheight)
            .attr("cursor", "ns-resize")
            .call(d3.drag()
            .subject(firstArgThis(this.durationSubject))
            .on("drag", firstArgThis(this.durationDragged)));
        // Update all nodes
        const allNodes = newNodes
            .merge(allExistingNodes)
            .attr("transform", (slide) => {
            this._previousSlideY = this.previousSlidesHeight(slide);
            return "translate(30," + this.previousSlidesHeight(slide) + ")";
        });
        allNodes
            .select("rect.slides_delay_rect")
            .attr("height", (slide) => {
            return this.barDelayHeight(slide);
        });
        allNodes
            .select("rect.slides_delay_resize")
            .attr("y", (slide) => {
            return this.barDelayHeight(slide);
        });
        slideGroup = allNodes.select("g.slide_group");
        slideGroup
            .select("rect.slides_rect")
            .attr("selected", (slide) => {
            return this._slideDeck.selectedSlide === slide;
        })
            .attr("y", (slide) => {
            return this.barDelayHeight(slide) + this._resizebarheight;
        })
            .attr("height", (slide) => {
            this._placeholderY =
                this._previousSlideY +
                    this.barDurationHeight(slide) +
                    this.barDelayHeight(slide) +
                    this._resizebarheight;
            return this.barDurationHeight(slide);
        });
        toolbar = allNodes.select("g.slide_toolbar");
        toolbar
            .select("foreignObject.slides_delete_icon")
            .attr("y", (slide) => {
            return (this.barDelayHeight(slide) +
                this._resizebarheight +
                2 * this._barPadding);
        });
        toolbar
            .select("foreignObject.slides_clone_icon")
            .attr("y", (slide) => {
            return (this.barDelayHeight(slide) +
                this._resizebarheight +
                2 * this._barPadding);
        });
        slideGroup
            .select("text.slides_text")
            .attr("y", (slide) => {
            return (this.barDelayHeight(slide) +
                this._resizebarheight +
                2 * this._barPadding);
        })
            .text((slide) => {
            return slide.name;
        });
        slideGroup
            .select("text.slides_delaytext")
            .attr("y", (slide) => {
            return (this.barDelayHeight(slide) +
                this._resizebarheight +
                1 * this._barPadding +
                25);
        })
            .text((slide) => {
            return "transition: " + slide.delay / 1000;
        });
        allNodes.select("circle.time").attr("cy", (slide) => {
            return this.barDelayHeight(slide) + this._resizebarheight;
        });
        allNodes
            .select("rect.slides_duration_resize")
            .attr("y", (slide) => {
            return this.barTotalHeight(slide) - this._resizebarheight;
        });
        allNodes
            .select("text.slides_durationtext")
            .attr("y", (slide) => {
            return (this.barDelayHeight(slide) +
                this._resizebarheight +
                4 * this._barPadding -
                7);
        })
            .text((slide) => {
            return slide.duration / 1000;
        });
        slidePlaceholder.attr("y", this._placeholderY + 20);
        playerPlaceholder.attr("y", 5);
        this._slideTable.select("line").attr("y2", this._placeholderY + 20);
        this._slideTable
            .select("foreignObject.slide_add")
            .attr("y", this._placeholderY + 26);
        this.animate();
        allExistingNodes.exit().remove();
    }
    animate() {
        if (this._player.status === provenance_core_1.STATUS.PLAYING) {
            this._slideTable
                .select(".currentTime")
                .transition()
                .ease(d3.easeLinear)
                .duration(this._slideDuration)
                .attr("cy", this._nextSlideY)
                .on("end", () => this.isLastSlide());
        }
        else {
            this._slideTable
                .select(".currentTime")
                .transition()
                .ease(d3.easeLinear)
                .duration(0);
        }
    }
    isLastSlide() {
        if (this._slideDeck.selectedSlide !== null) {
            if (this._slideDeck.slides.indexOf(this._slideDeck.selectedSlide) ===
                this._slideDeck.slides.length - 1) {
                setTimeout(() => {
                    this._nextSlideY = 50;
                    this._slideTable
                        .select(".currentTime")
                        .attr("cy", this._nextSlideY);
                    this._slideDeck.selectedSlide = this._slideDeck.slides[0];
                    this._slideTable
                        .select(".fa-pause")
                        .classed("fa-play", true)
                        .classed("fa-pause", false);
                    this._player.stop();
                    this._player.currentSlideIndex = 0;
                }, 2000);
            }
        }
    }
    setPlaceholder(id) {
        this._slideTable
            .append("rect")
            .attr("id", id)
            .attr("class", "slides_placeholder")
            .attr("x", this._lineX1 + this._barPadding)
            .attr("y", 0)
            .attr("width", this._placeholderWidth)
            .attr("height", this._placeholderHeight);
    }
    setAddButton() {
        this._slideTable
            .append("svg:foreignObject")
            .attr("class", "slide_add")
            .attr("x", (this._tableWidth - 40) / 2)
            .attr("cursor", "pointer")
            .attr("width", 30)
            .attr("height", 30)
            .append("xhtml:body")
            .on("click", this.onAdd)
            .html('<i class="fa fa-file-text-o"></i>');
    }
    setPlayButton() {
        this._slideTable
            .append("svg:foreignObject")
            .attr("id", "slide_play")
            .attr("x", (this._tableWidth - 40) / 2 + 30)
            .attr("y", 10)
            .attr("cursor", "pointer")
            .attr("width", 30)
            .attr("height", 30)
            .append("xhtml:body")
            .on("click", this.onPlay)
            .html('<i class="fa fa-play"></i>');
    }
    setNextButton() {
        this._slideTable
            .append("svg:foreignObject")
            .attr("x", (this._tableWidth - 40) / 2 + 60)
            .attr("y", 10)
            .attr("cursor", "pointer")
            .attr("width", 30)
            .attr("height", 30)
            .append("xhtml:body")
            .on("click", this.onNext)
            .html('<i class="fa fa-forward"></i>');
    }
    setPreviousButton() {
        this._slideTable
            .append("svg:foreignObject")
            .attr("x", (this._tableWidth - 40) / 2 - 10)
            .attr("y", 10)
            .attr("cursor", "pointer")
            .attr("width", 30)
            .attr("height", 30)
            .append("xhtml:body")
            .on("click", this.onPrevious)
            .html('<i class="fa fa-backward"></i>');
    }
}
exports.SlideDeckVisualization = SlideDeckVisualization;
//# sourceMappingURL=slide-deck-visualization.js.map